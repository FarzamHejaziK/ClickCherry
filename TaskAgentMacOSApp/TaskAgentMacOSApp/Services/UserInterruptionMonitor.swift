import ApplicationServices
import Foundation

protocol UserInterruptionMonitor {
    /// Starts monitoring for user activity (mouse/keyboard). Returns `true` if monitoring started.
    func start(onUserInterruption: @escaping () -> Void) -> Bool
    func stop()
}

final class QuartzUserInterruptionMonitor: UserInterruptionMonitor {
    private var eventTap: CFMachPort?
    private var runLoopSource: CFRunLoopSource?
    private var didTrigger: Bool = false
    private var onUserInterruption: (() -> Void)?
    private let lock = NSLock()
    private let escapeKeyCode: Int64 = 53 // kVK_Escape

    func start(onUserInterruption: @escaping () -> Void) -> Bool {
        guard Thread.isMainThread else {
            var started = false
            DispatchQueue.main.sync {
                started = self.start(onUserInterruption: onUserInterruption)
            }
            return started
        }

        stop()

        lock.lock()
        didTrigger = false
        self.onUserInterruption = onUserInterruption
        lock.unlock()

        // Only cancel when user presses Escape (explicit takeover).
        let types: [CGEventType] = [.keyDown]
        let mask = Self.mask(for: types)
        let refcon = UnsafeMutableRawPointer(Unmanaged.passUnretained(self).toOpaque())
        guard let tap = CGEvent.tapCreate(
            tap: .cgSessionEventTap,
            place: .headInsertEventTap,
            options: .listenOnly,
            eventsOfInterest: mask,
            callback: Self.eventTapCallback,
            userInfo: refcon
        ) else {
            return false
        }

        let source = CFMachPortCreateRunLoopSource(kCFAllocatorDefault, tap, 0)
        CFRunLoopAddSource(CFRunLoopGetMain(), source, .commonModes)
        CGEvent.tapEnable(tap: tap, enable: true)

        eventTap = tap
        runLoopSource = source
        return true
    }

    func stop() {
        guard Thread.isMainThread else {
            DispatchQueue.main.async { [weak self] in
                self?.stop()
            }
            return
        }

        if let tap = eventTap {
            CGEvent.tapEnable(tap: tap, enable: false)
        }
        if let source = runLoopSource {
            CFRunLoopRemoveSource(CFRunLoopGetMain(), source, .commonModes)
        }
        if let tap = eventTap {
            CFMachPortInvalidate(tap)
        }

        eventTap = nil
        runLoopSource = nil

        lock.lock()
        onUserInterruption = nil
        didTrigger = false
        lock.unlock()
    }

    private static func mask(for types: [CGEventType]) -> CGEventMask {
        types.reduce(0) { mask, type in
            mask | ((1 as CGEventMask) << CGEventMask(type.rawValue))
        }
    }

    private static let eventTapCallback: CGEventTapCallBack = { _, type, event, refcon in
        guard let refcon else {
            return Unmanaged.passUnretained(event)
        }
        let monitor = Unmanaged<QuartzUserInterruptionMonitor>.fromOpaque(refcon).takeUnretainedValue()
        return monitor.handleEvent(type: type, event: event)
    }

    private func handleEvent(type: CGEventType, event: CGEvent) -> Unmanaged<CGEvent>? {
        if type == .tapDisabledByTimeout || type == .tapDisabledByUserInput {
            if let tap = eventTap {
                CGEvent.tapEnable(tap: tap, enable: true)
            }
            return Unmanaged.passUnretained(event)
        }

        if type == .keyDown {
            // Only Escape should stop the run.
            let keycode = event.getIntegerValueField(.keyboardEventKeycode)
            if keycode != escapeKeyCode {
                return Unmanaged.passUnretained(event)
            }
        } else {
            // Should not happen (we only listen to `.keyDown`), but keep safe behavior.
            return Unmanaged.passUnretained(event)
        }

        // Ignore synthetic events generated by our own executor.
        let userData = event.getIntegerValueField(.eventSourceUserData)
        if userData == DesktopEventSignature.syntheticEventUserData {
            return Unmanaged.passUnretained(event)
        }

        var shouldFire = false
        lock.lock()
        if !didTrigger {
            didTrigger = true
            shouldFire = true
        }
        let handler = onUserInterruption
        lock.unlock()

        if shouldFire, let handler {
            DispatchQueue.main.async {
                handler()
            }
        }

        return Unmanaged.passUnretained(event)
    }
}
