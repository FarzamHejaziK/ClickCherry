name: Release

on:
  push:
    tags:
      - 'v*.*.*'
  workflow_dispatch:

permissions:
  contents: write

jobs:
  build:
    runs-on: macos-15
    steps:
      - uses: actions/checkout@v4

      - name: Validate signing/notarization secrets
        run: |
          test -n "${{ secrets.APPLE_DEVELOPER_ID_APPLICATION_CERT_BASE64 }}"
          test -n "${{ secrets.APPLE_DEVELOPER_ID_APPLICATION_CERT_PASSWORD }}"
          test -n "${{ secrets.APPLE_TEAM_ID }}"
          test -n "${{ secrets.APPLE_ID }}"
          test -n "${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}"

      - name: Import Developer ID certificate
        env:
          CERT_BASE64: ${{ secrets.APPLE_DEVELOPER_ID_APPLICATION_CERT_BASE64 }}
          CERT_PASSWORD: ${{ secrets.APPLE_DEVELOPER_ID_APPLICATION_CERT_PASSWORD }}
        run: |
          KEYCHAIN_PATH="$RUNNER_TEMP/build.keychain-db"
          KEYCHAIN_PASSWORD="$(openssl rand -hex 16)"
          CERT_PATH="$RUNNER_TEMP/developer-id.p12"
          echo "$CERT_BASE64" | base64 --decode > "$CERT_PATH"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security import "$CERT_PATH" -P "$CERT_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH"
          security default-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

      - name: Build app
        run: |
          xcodebuild -project TaskAgentMacOSApp/TaskAgentMacOSApp.xcodeproj \
            -scheme TaskAgentMacOSApp \
            -configuration Release \
            -destination "platform=macOS" \
            -derivedDataPath /tmp/taskagent-dd-release \
            CODE_SIGNING_ALLOWED=NO build

      - name: Sign app bundle
        run: |
          APP_PATH=$(find /tmp/taskagent-dd-release -name "ClickCherry.app" | head -n1)
          if [ -z "$APP_PATH" ]; then
            echo "Release app not found" >&2
            exit 1
          fi
          codesign --force --deep --options runtime --timestamp \
            --sign "Developer ID Application: Farzam Hejazikookamari (QKN8WTSJYG)" \
            "$APP_PATH"
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

      - name: Package app for notarization
        run: |
          APP_PATH=$(find /tmp/taskagent-dd-release -name "ClickCherry.app" | head -n1)
          if [ -z "$APP_PATH" ]; then
            echo "Release app not found" >&2
            exit 1
          fi
          ditto -c -k --sequesterRsrc --keepParent "$APP_PATH" ClickCherry-notary-input.zip

      - name: Submit app for notarization
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          xcrun notarytool submit ClickCherry-notary-input.zip \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --output-format json > notary-submit.json

          SUBMISSION_ID=$(ruby -rjson -e 'print JSON.parse(File.read("notary-submit.json"))["id"]')
          if [ -z "$SUBMISSION_ID" ]; then
            echo "Unable to parse notarization submission id" >&2
            cat notary-submit.json >&2
            exit 1
          fi

          echo "Notarization submission id: $SUBMISSION_ID"
          echo "NOTARY_SUBMISSION_ID=$SUBMISSION_ID" >> "$GITHUB_ENV"

      - name: Wait for notarization result
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          if [ -z "${NOTARY_SUBMISSION_ID:-}" ]; then
            echo "NOTARY_SUBMISSION_ID is not set" >&2
            exit 1
          fi

          START_EPOCH=$(date +%s)
          DEADLINE_EPOCH=$(( START_EPOCH + 5400 ))
          POLL_COUNT=0

          while [ "$(date +%s)" -lt "$DEADLINE_EPOCH" ]; do
            POLL_COUNT=$(( POLL_COUNT + 1 ))
            NOW_EPOCH=$(date +%s)
            ELAPSED_SECONDS=$(( NOW_EPOCH - START_EPOCH ))
            ELAPSED_MINUTES=$(( ELAPSED_SECONDS / 60 ))
            TIMESTAMP_UTC=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
            echo "[$TIMESTAMP_UTC] Poll #$POLL_COUNT (elapsed ${ELAPSED_MINUTES}m ${ELAPSED_SECONDS}s)"

            set +e
            INFO_JSON=$(xcrun notarytool info "$NOTARY_SUBMISSION_ID" \
              --apple-id "$APPLE_ID" \
              --password "$APPLE_APP_SPECIFIC_PASSWORD" \
              --team-id "$APPLE_TEAM_ID" \
              --output-format json 2> notary-info.err)
            INFO_EXIT=$?
            set -e

            if [ "$INFO_EXIT" -ne 0 ]; then
              if grep -Eq "NSURLErrorDomain Code=-1009|The Internet connection appears to be offline|timed out|networkConnectionLost" notary-info.err; then
                echo "[$TIMESTAMP_UTC] Transient notary network error; retrying in 30s"
                sleep 30
                continue
              fi

              echo "Failed to query notarization status" >&2
              cat notary-info.err >&2
              exit "$INFO_EXIT"
            fi

            STATUS=$(printf "%s" "$INFO_JSON" | ruby -rjson -e 'print JSON.parse(STDIN.read)["status"]')
            echo "[$TIMESTAMP_UTC] Notarization status: $STATUS"

            if [ "$STATUS" = "Accepted" ]; then
              exit 0
            fi

            if [ "$STATUS" = "Invalid" ] || [ "$STATUS" = "Rejected" ]; then
              echo "Notarization failed with status: $STATUS" >&2
              xcrun notarytool log "$NOTARY_SUBMISSION_ID" \
                --apple-id "$APPLE_ID" \
                --password "$APPLE_APP_SPECIFIC_PASSWORD" \
                --team-id "$APPLE_TEAM_ID" || true
              exit 1
            fi

            sleep 30
          done

          echo "Timed out waiting for notarization after 90 minutes" >&2
          xcrun notarytool info "$NOTARY_SUBMISSION_ID" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_APP_SPECIFIC_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" || true
          exit 1

      - name: Staple notarization ticket
        run: |
          APP_PATH=$(find /tmp/taskagent-dd-release -name "ClickCherry.app" | head -n1)
          if [ -z "$APP_PATH" ]; then
            echo "Release app not found" >&2
            exit 1
          fi
          xcrun stapler staple "$APP_PATH"
          xcrun stapler validate "$APP_PATH"
          spctl --assess --type execute --verbose=4 "$APP_PATH"
      - name: Build styled drag-to-install DMG
        run: |
          brew install create-dmg

          APP_PATH=$(find /tmp/taskagent-dd-release -name "ClickCherry.app" | head -n1)
          if [ -z "$APP_PATH" ]; then
            echo "Release app not found" >&2
            exit 1
          fi

          DMG_STAGING_DIR="$RUNNER_TEMP/dmg-root"
          DMG_BG_PATH="$RUNNER_TEMP/dmg-background.png"
          DMG_BG_SCRIPT="$RUNNER_TEMP/make_dmg_background.swift"

          rm -rf "$DMG_STAGING_DIR"
          mkdir -p "$DMG_STAGING_DIR"
          cp -R "$APP_PATH" "$DMG_STAGING_DIR/ClickCherry.app"

          cat > "$DMG_BG_SCRIPT" <<'SWIFT'
          import AppKit
          import Foundation

          guard CommandLine.arguments.count == 2 else {
              fputs("usage: make_dmg_background.swift <output-png>\n", stderr)
              exit(2)
          }

          let outputPath = CommandLine.arguments[1]
          let canvasSize = NSSize(width: 700, height: 420)
          let canvasRect = NSRect(origin: .zero, size: canvasSize)

          let image = NSImage(size: canvasSize)
          image.lockFocus()

          let gradient = NSGradient(colors: [
              NSColor(calibratedRed: 0.13, green: 0.10, blue: 0.14, alpha: 1.0),
              NSColor(calibratedRed: 0.30, green: 0.10, blue: 0.16, alpha: 1.0)
          ])!
          gradient.draw(in: canvasRect, angle: 0)

          let accentRect = NSRect(x: 0, y: 0, width: canvasSize.width, height: 120)
          NSColor(calibratedWhite: 1.0, alpha: 0.08).setFill()
          accentRect.fill(using: .sourceOver)

          let titleAttrs: [NSAttributedString.Key: Any] = [
              .font: NSFont.systemFont(ofSize: 34, weight: .bold),
              .foregroundColor: NSColor.white
          ]
          NSAttributedString(string: "Drag to install", attributes: titleAttrs)
              .draw(at: NSPoint(x: 278, y: 250))

          let subtitleAttrs: [NSAttributedString.Key: Any] = [
              .font: NSFont.systemFont(ofSize: 17, weight: .medium),
              .foregroundColor: NSColor(calibratedWhite: 1.0, alpha: 0.86)
          ]
          NSAttributedString(string: "Drop the app into Applications", attributes: subtitleAttrs)
              .draw(at: NSPoint(x: 278, y: 214))

          let arrowPath = NSBezierPath()
          arrowPath.move(to: NSPoint(x: 130, y: 176))
          arrowPath.line(to: NSPoint(x: 468, y: 176))
          arrowPath.lineWidth = 6
          NSColor(calibratedWhite: 1.0, alpha: 0.78).setStroke()
          arrowPath.stroke()

          let arrowHead = NSBezierPath()
          arrowHead.move(to: NSPoint(x: 468, y: 176))
          arrowHead.line(to: NSPoint(x: 442, y: 194))
          arrowHead.move(to: NSPoint(x: 468, y: 176))
          arrowHead.line(to: NSPoint(x: 442, y: 158))
          arrowHead.lineWidth = 6
          NSColor(calibratedWhite: 1.0, alpha: 0.78).setStroke()
          arrowHead.stroke()

          let targetRect = NSRect(x: 482, y: 118, width: 134, height: 134)
          let targetPath = NSBezierPath(roundedRect: targetRect, xRadius: 24, yRadius: 24)
          let dash: [CGFloat] = [11, 8]
          targetPath.setLineDash(dash, count: dash.count, phase: 0)
          targetPath.lineWidth = 3
          NSColor(calibratedWhite: 1.0, alpha: 0.36).setStroke()
          targetPath.stroke()

          image.unlockFocus()

          guard
              let tiffData = image.tiffRepresentation,
              let bitmap = NSBitmapImageRep(data: tiffData),
              let pngData = bitmap.representation(using: .png, properties: [:])
          else {
              fputs("failed to encode PNG\n", stderr)
              exit(3)
          }

          do {
              try pngData.write(to: URL(fileURLWithPath: outputPath), options: .atomic)
          } catch {
              fputs("failed to write PNG: \(error)\n", stderr)
              exit(4)
          }
          SWIFT

          swift "$DMG_BG_SCRIPT" "$DMG_BG_PATH"

          VOLICON_PATH="$APP_PATH/Contents/Resources/AppIcon.icns"
          VOLICON_ARGS=()
          if [ -f "$VOLICON_PATH" ]; then
            VOLICON_ARGS=(--volicon "$VOLICON_PATH")
          fi

          create-dmg \
            --volname "ClickCherry" \
            "${VOLICON_ARGS[@]}" \
            --background "$DMG_BG_PATH" \
            --window-pos 200 120 \
            --window-size 700 420 \
            --text-size 14 \
            --icon-size 120 \
            --icon "ClickCherry.app" 160 300 \
            --hide-extension "ClickCherry.app" \
            --app-drop-link 530 300 \
            --format UDZO \
            --hdiutil-quiet \
            --no-internet-enable \
            "ClickCherry-macos.dmg" \
            "$DMG_STAGING_DIR"

      - name: Upload release artifact
        uses: actions/upload-artifact@v4
        with:
          name: clickcherry-release
          path: |
            ClickCherry-macos.dmg

  publish:
    runs-on: ubuntu-latest
    needs: [build]
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - uses: actions/download-artifact@v4
        with:
          name: clickcherry-release

      - name: Build release notes
        run: |
          CURRENT_TAG="${GITHUB_REF_NAME}"
          CURRENT_VERSION="${CURRENT_TAG#v}"

          PREV_TAG=$(git tag --sort=-v:refname | grep -v "^${CURRENT_TAG}$" | head -n1 || true)

          if [ -n "$PREV_TAG" ]; then
            COMMIT_RANGE="${PREV_TAG}..${CURRENT_TAG}"
            CHANGELOG_URL="https://github.com/${{ github.repository }}/compare/${PREV_TAG}...${CURRENT_TAG}"
          else
            COMMIT_RANGE="${CURRENT_TAG}"
            CHANGELOG_URL="https://github.com/${{ github.repository }}/commits/${CURRENT_TAG}"
          fi

          git log --pretty='- %s' "${COMMIT_RANGE}" > .release-commits.txt

          grep -Ei '^- (fix|fixed|bug|hotfix|patch|resolve|resolved)\b' .release-commits.txt > .release-fixes.txt || true
          grep -Eiv '^- (fix|fixed|bug|hotfix|patch|resolve|resolved)\b' .release-commits.txt > .release-changes.txt || true

          {
            echo "### Changes"
            echo
            if [ -s .release-changes.txt ]; then
              cat .release-changes.txt
            else
              echo "- Maintenance and release pipeline updates."
            fi
            echo
            echo "### Fixes"
            echo
            if [ -s .release-fixes.txt ]; then
              cat .release-fixes.txt
            else
              echo "- No explicit fix-labeled commits in this release window."
            fi
            echo
            echo "### Artifacts"
            echo
            echo "- \`ClickCherry-macos.dmg\`"
            echo
            echo "**Full Changelog**: ${CHANGELOG_URL}"
          } > RELEASE_NOTES.md

      - name: Publish GitHub release
        uses: softprops/action-gh-release@v2
        with:
          name: ClickCherry ${{ github.ref_name }}
          files: |
            ClickCherry-macos.dmg
          generate_release_notes: false
          body_path: RELEASE_NOTES.md
